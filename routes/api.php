<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "api" middleware group. Make something great!
|
*/

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

/**
 * Returns a json array of all tickets that are not processed, optional pagination
 */
Route::get('/tickets/open/{page?}', function (Request $request, int $page = null) {
    $response = ['success' => false, "body" => [], "status" => 400];
    $perPage = 3;
    $currentPage =  $page ?: 1;
    $start = ($currentPage - 1) * $perPage;

    try {
        $openTickets = DB::table('ticket')
            ->offset($start)
            ->limit($perPage)
            ->where('status', [false])->orderBy('created_at', 'ASC')->get();
    } catch (Exception $e) {
        error_log($e);
        $response['error'] = 'Bad Request';
        return response($response, $response['status']);
    }
    //Check for results
    if(count($openTickets) === 0) {
        $response['error'] = "No open tickets were found";
        $response['status'] = 404;
        return response($response, $response['status']);
    }
    $response['success'] = true;
    $response['status'] = 200;
    $response['body'] = $openTickets;
    $response['page'] = $page ?: 1;
    return response($response);
});

/**
 * Returns a json array of all tickets that have been processed
 */
Route::get('/tickets/closed/{page?}', function (Request $request, $page = null) {
    $response = ['success' => false, "body" => [], "error" => "", "status" => 400];
    $perPage = 3;
    $currentPage =  $page ?: 1;
    $start = ($currentPage - 1) * $perPage;

    try {
        $openTickets = DB::table('ticket')
            ->offset($start)->limit($perPage)
            ->where('status', [true])->orderBy('created_at', 'ASC')->get();
    } catch (Exception $e) {
        error_log($e);
        $response['error'] = 'Bad Request';
        return response($response, $response['status']);
    }

    //Check for results
    if(count($openTickets) === 0) {
        $response['error'] = "No closed tickets were found";
        $response['status'] = 404;
        return response($response);
    }

    $response['success'] = true;
    $response['status'] = 200;
    $response['body'] = $openTickets;
    $response['page'] = $page ?: 1;
    return response($response);
});

Route::get('/users/{email}/tickets', function (Request $request, string $email) {
    $regexEmail = "/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/";
    $response = ['success' => false, "body" => [], "status" => 400];

    // Check for valid email, pattern is based off W3S Spec
    if(!preg_match($regexEmail, $email)) {
        $response['error'] = "not a valid email";
        return response($response, $response['status']);
    }
    try {
        $userTickets = DB::table('ticket')
            ->join('users', 'ticket.user_id', '=', 'users.id')
            ->where('email', $email)->get()
            ->select('subject', 'content', 'status', 'ticket.created_at', 'ticket.updated_at');

        // Check this user has tickets
        if(count($userTickets) === 0) {
            $response['error'] = "Failed to find your results";
            error_log("Found email but had no tickets connected");
            return response($response, $response["status"]);
        }

        $response['body'] = $userTickets;
        $response['success'] = true;
        $response['status'] = 200;
        return response($response);

    } catch (Exception $e) {
        error_log($e);
        $response['error'] = 'Bad Request';
        return response($response, $response['status']);
    }
});

Route::get('/stats', function () {
    $response = ['success' => false, "body" => [], "status" => 400];

    try {
        $tickets = DB::table('ticket')->join('users', 'ticket.user_id', '=', 'users.id')
            ->select("ticket.id", "ticket.updated_at", "status", "name", "email")
            ->orderBy('ticket.updated_at', 'ASC')->get();
        $unprocessed = 0;
        $processed = 0;
        $processedArr = [];

        $freqArr = [];
        $count = count($tickets);
        $mostSubmittedUser = '';

        // Check we got results back
        if($count === 0) {
            $response['error'] = "No results found";
            return response($response, $response["status"]);
        }

        // sort into processed and unprocessed, put user_id into array
        foreach ($tickets as $ticket) {
            if($ticket->status == 0) {
                $unprocessed++;
            } else {
                $processed++;
                $processedArr[] = $ticket;
            }
            // Add the email into an array
            $freqArr[] = $ticket->email;

        }

        // This produces an array of key(user.email) value(frequency) pairs, finds the max, and then returns
        // the max value
        $mostSubmissions = array_search(max(array_count_values($freqArr)), array_count_values($freqArr));

        // Use the most submitted id to get the name of the user
        foreach ($tickets as $ticket) {
            if($ticket->email === $mostSubmissions) {
                $mostSubmittedUser = $ticket->name;
                break;
            }
        }

        // since we orderBy last_updated, we can just grab the last item in the collection to get the last processed
        // ticket
        $lastProcessed = end($processedArr);
        error_log(json_encode($lastProcessed));

        $response['body'] = [
            'total' => $count,
            'unprocessed' => $unprocessed,
            'processed' => $processed,
            'mostSubmitted' => $mostSubmittedUser,
            'lastProcessed' => $lastProcessed->updated_at
        ];
        $response['success'] = true;
        $response['status'] = 200;
        return $response;
    } catch (Exception $e) {
        error_log($e);
        $response['error'] = 'Bad Request';
        return response($response, $response['status']);
    }
});
